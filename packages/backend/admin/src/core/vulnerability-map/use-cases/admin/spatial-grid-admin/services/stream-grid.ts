"use strict";

import distance from "@turf/distance";
import intersect from "@turf/intersect";
import * as turf from "@turf/turf";
import { CommonArea } from "@rrrcn/admin/src/core/common/entities/area";
import GeoJSON from "geojson";
/**
 * Takes a bounding box and a cell depth and returns a set of triangular {@link Polygon|polygons} in a grid.
 *
 * @name squareGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSide dimension of each cell
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers
 * @param {Feature<Polygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it
 * @param {Object} [options.properties={}] passed to each point of the grid
 * @returns {FeatureCollection<Polygon>} grid of polygons
 * @example
 * var bbox = [-95, 30 ,-85, 40]
 * var cellSide = 50
 * var options = {units: 'miles'}
 *
 * var squareGrid = turf.squareGrid(bbox, cellSide, options)
 *
 * //addToMap
 * var addToMap = [squareGrid]
 */

let squareStream = null;

function squareGridStream(
  bbox: GeoJSON.BBox,
  cellSide: number,
  options
): Promise<Generator<CommonArea | null, CommonArea | null, unknown>> {
  return new Promise((resolve, reject) => {
    squareStream = squareGridGenerator(bbox, cellSide, options);
    if (squareStream) resolve(squareStream);
    else reject("Failed to generate stream");
  });
}

function* squareGridGenerator(bbox: GeoJSON.BBox, cellSide: number, options) {
  if (options === void 0) {
    options = {};
  }
  const offset = options.offset || 0;
  const xFraction =
    cellSide / distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], options);
  const cellWidth = xFraction * (bbox[2] - bbox[0]);
  const yFraction =
    cellSide / distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], options);
  const cellHeight = yFraction * (bbox[3] - bbox[1]);
  if (!cellHeight || !cellWidth) {
    throw "!cellHeight||!cellWidth";
  }
  let xi = 0;
  let currentX = bbox[0] - offset * cellWidth;
  while (currentX <= bbox[2] + offset * cellWidth) {
    let yi = 0;
    let currentY = bbox[1] - offset * cellHeight;
    while (currentY <= bbox[3] + offset * cellHeight) {
      let cellSquare: null | GeoJSON.Feature<
        GeoJSON.Polygon | GeoJSON.MultiPolygon
      > = null;
      cellSquare = turf.polygon(
        [
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY],
          ],
        ],
        options.properties
      );

      if (options.mask) {
        const intersection = intersect(options.mask, cellSquare.geometry);
        if (intersection?.geometry) {
          yield new CommonArea(cellSquare);
        } else {
          yield null;
        }
      } else {
        yield new CommonArea(cellSquare);
      }
      currentY += cellHeight;
      yi++;
    }
    xi++;
    currentX += cellWidth;
  }
}

export default squareGridStream;
