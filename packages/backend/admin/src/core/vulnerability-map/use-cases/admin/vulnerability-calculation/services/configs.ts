import { IMapVulnerabilityResultRepository } from "@rrrcn/admin/src/core/vulnerability-map/repository/vulnerability-result";
import { IMapMigrationsRepository } from "@rrrcn/admin/src/core/vulnerability-map/repository/migrations";
import { IMapMigrationTrack } from "@rrrcn/admin/src/core/vulnerability-map/entities/migration-track";
import { GeoJSON } from "geojson";
import { distance } from "@turf/turf";
import { rrrcnServicesClient } from "@rrrcn/admin/src/rrrcn-services-client";

export class MapVulnerabilityConfigsCalculationService<IdType> {
  private migrationRepository: IMapMigrationsRepository<IdType>;
  private vulnerabilityResultRepository: IMapVulnerabilityResultRepository<IdType>;
  private rrrcnServicesClient = rrrcnServicesClient;
  constructor(
    migrationRepository: IMapMigrationsRepository<IdType>,
    vulnerabilityResultRepository: IMapVulnerabilityResultRepository<IdType>
  ) {
    this.migrationRepository = migrationRepository;
    this.vulnerabilityResultRepository = vulnerabilityResultRepository;
  }
  async calculateTracksConfig({
    migrationTracksIds,
    rotor,
  }: {
    migrationTracksIds: IdType[];
    rotor?: [number, number];
  }) {
    const migrationsTracks = await this.migrationRepository.getMigrationsTracks(
      { trackIds: migrationTracksIds }
    );
    console.log(migrationsTracks.length);
    const allFlightSpeeds = [];
    const allCalcFlightSpeeds = [];
    let totalLocations = 0;
    let totalFlightLocations = 0;
    let totalFlightLocationsByCalc = 0;
    const flightHeights = new Map<number, number>();
    for (const migrationTrack of migrationsTracks) {
      totalLocations += migrationTrack.track.features.length;
      const {
        speeds: calcpeeds,
        locationsIndices: flightLocationsByCalcIndices,
      } = this.getTrackFlightLocationsAndSpeed(
        migrationTrack,
        this.getTrackCalculatedSpeed
      );
      const { speeds, locationsIndices: flightLocationsIndices } =
        this.getTrackFlightLocationsAndSpeed(migrationTrack, (track) =>
          track.track.features.map((it) => it.properties.speed)
        );

      totalFlightLocations += flightLocationsIndices.size;
      totalFlightLocationsByCalc += flightLocationsByCalcIndices.size;

      speeds.forEach((it, index) => {
        if (flightLocationsIndices.has(index)) {
          allFlightSpeeds.push(it);
        }
      });

      calcpeeds.forEach((it, index) => {
        if (flightLocationsByCalcIndices.has(index)) {
          allCalcFlightSpeeds.push(it);
        }
      });
      const flightLocations = migrationTrack.track.features.filter(
        (it, index) => flightLocationsIndices.has(index)
      );
      const trackElevations = await this.getTrackElevations(
        migrationTrack.track.features.filter((it, index) =>
          flightLocationsIndices.has(index)
        )
      );
      trackElevations.forEach((elevation, index) => {
        const altitude = flightLocations[index].properties.altitude;
        const realElevation = altitude - elevation;
        if (!flightHeights.has(realElevation)) {
          flightHeights.set(realElevation, 1);
        } else {
          flightHeights.set(
            realElevation,
            flightHeights.get(realElevation) + 1
          );
        }
      });
    }
    const flightHeightsArray = Array.from(flightHeights.entries());
    const atRotorHeight = rotor
      ? flightHeightsArray
          .filter(([height, count]) => {
            if (height >= rotor[0] && height <= rotor[1]) {
              return true;
            }
          })
          .reduce((acc, [_, count]) => acc + count, 0)
      : null;
    const all = flightHeightsArray.reduce((acc, [_, count]) => acc + count, 0);
    const percentAtRotorHeight =
      atRotorHeight && (all ? atRotorHeight / all : 0);
    return await this.vulnerabilityResultRepository.createVulnerabilityConfigCalculation(
      {
        flightHeights: flightHeightsArray,
        trackIds: migrationTracksIds,
        averageSpeed: allFlightSpeeds.length
          ? allFlightSpeeds.reduce((a, b) => a + b) / allFlightSpeeds.length
          : 0,
        averageCalcSpeed: allCalcFlightSpeeds.length
          ? allCalcFlightSpeeds.reduce((a, b) => a + b) /
            allCalcFlightSpeeds.length
          : 0,
        flightLocationsPercent: totalLocations
          ? totalFlightLocations / totalLocations
          : 0,
        flightLocationsPercentByCalc: totalLocations
          ? totalFlightLocationsByCalc / totalLocations
          : 0,
        rotor,
        percentAtRotorHeight,
      }
    );
  }
  private getTrackFlightLocationsAndSpeed(
    track: IMapMigrationTrack<IdType>,
    getSpeeds: (track: IMapMigrationTrack<IdType>) => number[]
  ): { locationsIndices: Set<number>; speeds: number[] } {
    const speeds = getSpeeds(track);
    const flightLocationsIndices = this.getTrackFlightLocationsIndices(
      track,
      speeds
    );
    return {
      locationsIndices: flightLocationsIndices,
      speeds,
    };
  }
  private async getTrackElevations(
    points: GeoJSON.Feature<GeoJSON.Point>[]
  ): Promise<number[]> {
    const chunkSize = 2000;
    const allPoints = [];
    for (let i = 0; i < points.length; i += chunkSize) {
      const chunk = points.slice(i, i + chunkSize);
      const pointsWithElevation = await rrrcnServicesClient.getPointsElevations(
        chunk
      );
      allPoints.push(...pointsWithElevation);
    }
    return allPoints.map((it) => it.properties.elevation as number);
  }
  private getTrackCalculatedSpeed(track: IMapMigrationTrack<IdType>) {
    return track.track.features.map((it, index, arr) => {
      const calcSpeed = arr[index + 1]
        ? pointSpeed(it, arr[index + 1])
        : arr[index - 1]
        ? pointSpeed(arr[index - 1], it)
        : 0;
      return calcSpeed;
    });
  }
  private getTrackFlightLocationsIndices(
    track: IMapMigrationTrack<IdType>,
    calcSpeed: number[]
  ) {
    const indices = new Set<number>();
    track.track.features.forEach((it, index) => {
      if (calcSpeed[index] >= 5) {
        indices.add(index);
      }
    });
    return indices;
  }
}
function pointSpeed(
  point: GeoJSON.Feature<GeoJSON.Point>,
  nextPoint: GeoJSON.Feature<GeoJSON.Point>
) {
  const firstPointTime: Date = new Date(point.properties?.date);
  const secondPointTime: Date = new Date(nextPoint.properties?.date);
  try {
    if (!firstPointTime || !secondPointTime) {
      return 0;
    }
    const _distance = distance(point, nextPoint, { units: "kilometers" });
    const timeDiff = secondPointTime.getTime() - firstPointTime.getTime();
    const timeDiffHours = timeDiff / (1000 * 60 * 60);
    if (!timeDiffHours) {
      return 0;
    }
    return Math.abs(_distance / timeDiffHours);
  } catch (e) {
    console.log({ firstPointTime, secondPointTime });
    return 0;
  }
}
